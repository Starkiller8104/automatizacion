# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18xSjlYum0k2ndcM1f52KaFCunTC81E2U
"""
# app.py
# ─────────────────────────────────────────────────────────────
# Panel de Indicadores Económicos MX (Banxico + INEGI UMA)
# Formato Excel exacto + Gráficos
#
# Requisitos:
#   pip install streamlit pandas openpyxl matplotlib requests python-dateutil
#
# Ejecuta:
#   streamlit run app.py
#

import io
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import requests
import matplotlib.pyplot as plt
import streamlit as st

from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, Border, Side
from openpyxl.utils import get_column_letter

# ─────────── TOKENS INTEGRADOS ───────────
BANXICO_TOKEN = "677aaedf11d11712aa2ccf73da4d77b6b785474eaeb2e092f6bad31b29de6609"
INEGI_TOKEN   = "9886fe68-e51f-c345-0b8f-adb99da1a1fd"

# ─────────── IDs de Banxico (EDITABLES en un solo lugar) ───────────
# Si algún ID no coincide con tu flujo, cámbialo aquí y corre.
BANXICO_SERIES = {
    # Tipos de cambio
    "usd_mxn":  "SF43718",   # FIX USD/MXN
    "movex":    "",          # Si manejas MOVEX, coloca el ID aquí
    "usd_buy":  "",          # Compra (tu fuente/ID)
    "usd_sell": "",          # Venta  (tu fuente/ID)

    # Yen / Euro
    "usd_jpy":  "",          # Si tienes serie USD/JPY en Banxico, colócala. Si la dejas vacía puedes meter valor manual y lo repetirá.
    "eur_mxn":  "",          # Si no la tienes, se calculará desde (EUR/USD * USD/MXN) si das eur_usd
    "eur_usd":  "",          # Si no la tienes, se calculará (EUR/MXN / USD/MXN) si das eur_mxn

    # UDIS
    "udis":     "SP68257",   # UDIS diarias (ajústalo si tu ID es otro)

    # TIIE (tasa objetivo y plazos) – pueden variar según fuente/definición en SIE
    "tiie_obj": "",          # Tasa objetivo de política monetaria (coloca tu ID)
    "tiie_28":  "",          # TIIE 28 días
    "tiie_91":  "",          # TIIE 91 días
    "tiie_182": "",          # TIIE 182 días

    # CETES (rendimientos por plazo) – ajusta según tus IDs de SIE
    "cetes_28":  "",         # CETES 28 días
    "cetes_91":  "",         # CETES 91 días
    "cetes_182": "",         # CETES 182 días
    "cetes_364": "",         # CETES 364 días
}

# ─────────── Fechas ───────────
def last_business_days(n: int, end: Optional[date] = None) -> List[date]:
    if end is None:
        end = datetime.now().date()
    out = []
    d = end
    while len(out) < n:
        if d.weekday() < 5:
            out.append(d)
        d -= timedelta(days=1)
    return sorted(out)

def range_buffer_for(fechas: List[date]) -> Tuple[date, date]:
    return fechas[0] - timedelta(days=10), fechas[-1] + timedelta(days=2)

# ─────────── Util ───────────
def _parse_float(x: str) -> Optional[float]:
    try:
        return float(str(x).replace(",", ""))
    except Exception:
        return None

# ─────────── Banxico API ───────────
def banxico_series_range(series_id: str, start: date, end: date) -> Dict[date, float]:
    """Devuelve dict {fecha: valor} para una serie de Banxico en el rango dado."""
    url = f"https://www.banxico.org.mx/SieAPIRest/service/v1/series/{series_id}/datos/{start:%Y-%m-%d}/{end:%Y-%m-%d}"
    headers = {"Bmx-Token": BANXICO_TOKEN}
    r = requests.get(url, headers=headers, timeout=30)
    r.raise_for_status()
    js = r.json()
    out = {}
    try:
        for item in js["bmx"]["series"][0]["datos"]:
            d = datetime.strptime(item["fecha"], "%d/%m/%Y").date()
            v = _parse_float(item["dato"])
            if v is not None:
                out[d] = v
    except Exception:
        pass
    return out

# ─────────── INEGI UMA ───────────
def inegi_uma(token: str) -> Tuple[Optional[float], Optional[float], Optional[float]]:
    """Regresa (UMA_diaria, UMA_mensual, UMA_anual) desde BIE."""
    indicadores = {
        "diaria":  "6207068168",
        "mensual": "6207068170",
        "anual":   "6207068172",
    }
    vals = {}
    for k, code in indicadores.items():
        url = (
            f"https://www.inegi.org.mx/app/api/indicadores/desarrolladores/jsonxml/INDICATOR/"
            f"{code}/es/0700/false/BIE/2.0/{token}?type=json"
        )
        try:
            r = requests.get(url, timeout=25)
            r.raise_for_status()
            js = r.json()
            series = js.get("Series", [])
            if series and series[0].get("OBSERVATIONS"):
                vals[k] = _parse_float(series[0]["OBSERVATIONS"][-1]["OBS_VALUE"])
            else:
                vals[k] = None
        except Exception:
            vals[k] = None
    return vals.get("diaria"), vals.get("mensual"), vals.get("anual")

# ─────────── Construcción de history ───────────
def align_to_dates(series_map: Dict[date, float], fechas: List[date]) -> List[Optional[float]]:
    out, last_val = [], None
    for d in fechas:
        if d in series_map:
            last_val = series_map[d]
        out.append(last_val)  # forward-fill (None si aún no hay dato)
    return out

def get_series(key: str, fechas: List[date]) -> Dict[date, float]:
    sid = BANXICO_SERIES.get(key, "")
    if not sid:
        return {}
    start, end = range_buffer_for(fechas)
    return banxico_series_range(sid, start, end)

def compute_history(fechas: List[date]) -> Tuple[Dict[str, List[Optional[float]]], pd.DataFrame]:
    """Descarga/deriva todas las series necesarias y genera history + hoja cruda."""
    raw = {}

    # Core FX
    raw["usd_mxn"] = get_series("usd_mxn", fechas)
    raw["usd_jpy"] = get_series("usd_jpy", fechas)  # si está vacío, se omitirá
    raw["eur_mxn"] = get_series("eur_mxn", fechas)
    raw["eur_usd"] = get_series("eur_usd", fechas)
    # MOVEX / Compra / Venta (si configuras IDs)
    raw["movex"]   = get_series("movex", fechas)
    raw["usd_buy"] = get_series("usd_buy", fechas)
    raw["usd_sell"]= get_series("usd_sell", fechas)

    # UDIS
    raw["udis"]    = get_series("udis", fechas)

    # TIIE
    raw["tiie_obj"] = get_series("tiie_obj", fechas)
    raw["tiie_28"]  = get_series("tiie_28", fechas)
    raw["tiie_91"]  = get_series("tiie_91", fechas)
    raw["tiie_182"] = get_series("tiie_182", fechas)

    # CETES
    raw["cetes_28"]  = get_series("cetes_28", fechas)
    raw["cetes_91"]  = get_series("cetes_91", fechas)
    raw["cetes_182"] = get_series("cetes_182", fechas)
    raw["cetes_364"] = get_series("cetes_364", fechas)

    # UMA (INEGI) → solo el día actual
    uma_d, uma_m, uma_a = inegi_uma(INEGI_TOKEN)
    if uma_d is not None:
        raw["uma_diaria"]  = {fechas[-1]: uma_d}
    if uma_m is not None:
        raw["uma_mensual"] = {fechas[-1]: uma_m}
    if uma_a is not None:
        raw["uma_anual"]   = {fechas[-1]: uma_a}

    # Derivados:
    # JPY/MXN = (USD/MXN) * (USD/JPY)
    jpy_mxn = {}
    for d in fechas:
        u_mxn = raw.get("usd_mxn", {}).get(d)
        u_jpy = raw.get("usd_jpy", {}).get(d)
        if u_mxn is not None and u_jpy is not None:
            jpy_mxn[d] = u_mxn * u_jpy
    raw["jpy_mxn"] = jpy_mxn

    # Completar EUR/USD si falta (eur_mxn / usd_mxn)
    if not raw.get("eur_usd"):
        eu = {}
        for d in fechas:
            em = raw.get("eur_mxn", {}).get(d)
            um = raw.get("usd_mxn", {}).get(d)
            if em is not None and um not in (None, 0):
                eu[d] = em / um
        raw["eur_usd"] = eu

    # Completar EUR/MXN si falta (eur_usd * usd_mxn)
    if not raw.get("eur_mxn"):
        em = {}
        for d in fechas:
            eu = raw.get("eur_usd", {}).get(d)
            um = raw.get("usd_mxn", {}).get(d)
            if eu is not None and um is not None:
                em[d] = eu * um
        raw["eur_mxn"] = em

    # Alinear a 6 fechas
    history = {k: align_to_dates(v, fechas) for k, v in raw.items()}

    # Hoja cruda
    rows = []
    for k, mp in raw.items():
        for d, val in sorted(mp.items()):
            rows.append({"fecha": d.strftime("%Y-%m-%d"), "serie": k, "valor": val})
    raw_df = pd.DataFrame(rows).sort_values(["serie", "fecha"]).reset_index(drop=True)

    return history, raw_df

# ─────────── Layout solicitado ───────────
LAYOUT_ROWS = [
    "TIPOS DE CAMBIO:", "",
    "DÓLAR AMERICANO.",
    "Dólar/Pesos:", "MOVEX:", "Compra:", "Venta:", "",
    "YEN JAPONÉS.",
    "Yen Japonés/Peso:", "Dólar/Yen Japonés:", "",
    "EURO.",
    "Euro/Peso:", "Euro/Dólar:", "",
    "UDIS:", "", "UDIS:", "",
    "TASAS TIIE:", "",
    "TIIE objetivo:", "TIIE 28 Días:", "TIIE 91 Días:", "TIIE 182 Días:", "",
    "CETES:", "",
    "CETES 28 Días:", "CETES 91 Días:", "Cetes 182 Días:", "Cetes 364 Días:", "",
    "UMA:", "",
    "Diario:", "Mensual:", "Anual:",
]

SECTION_LABELS = {
    "TIPOS DE CAMBIO:", "DÓLAR AMERICANO.", "YEN JAPONÉS.", "EURO.",
    "UDIS:", "TASAS TIIE:", "CETES:", "UMA:"
}

KEY_MAP = {
    "Dólar/Pesos:": "usd_mxn",
    "MOVEX:": "movex",
    "Compra:": "usd_buy",
    "Venta:": "usd_sell",
    "Yen Japonés/Peso:": "jpy_mxn",
    "Dólar/Yen Japonés:": "usd_jpy",
    "Euro/Peso:": "eur_mxn",
    "Euro/Dólar:": "eur_usd",
    "UDIS:": "udis",
    "TIIE objetivo:": "tiie_obj",
    "TIIE 28 Días:": "tiie_28",
    "TIIE 91 Días:": "tiie_91",
    "TIIE 182 Días:": "tiie_182",
    "CETES 28 Días:": "cetes_28",
    "CETES 91 Días:": "cetes_91",
    "Cetes 182 Días:": "cetes_182",
    "Cetes 364 Días:": "cetes_364",
    "Diario:": "uma_diaria",
    "Mensual:": "uma_mensual",
    "Anual:": "uma_anual",
}

def build_layout_df(history: Dict[str, List[Optional[float]]], fechas: List[date]) -> pd.DataFrame:
    cols = ["Fecha:", "Día 1", "Día 2", "Día 3", "Día 4", "Día 5", "Día actual"]
    df = pd.DataFrame(columns=cols)
    # Fila 1: rótulos
    df.loc[len(df)] = ["Fecha:"] + [None]*6
    # Fila 2: fechas
    f = [d.strftime("%d/%m/%Y") for d in fechas]
    df.loc[len(df)] = [""] + f[:5] + [f[5]]

    for label in LAYOUT_ROWS:
        if label == "":
            df.loc[len(df)] = [""] + [None]*6
            continue
        if label in SECTION_LABELS:
            df.loc[len(df)] = [label] + [None]*6
            continue
        key = KEY_MAP.get(label, "")
        vals = history.get(key, [None]*6)
        df.loc[len(df)] = [label] + vals
    return df

# ─────────── Excel ───────────
def export_to_excel(df: pd.DataFrame, raw_df: Optional[pd.DataFrame], add_raw: bool) -> bytes:
    wb = Workbook()
    ws = wb.active
    ws.title = "Indicadores"
    # Volcar tabla
    for r, row in enumerate(df.itertuples(index=False), start=1):
        for c, val in enumerate(row, start=1):
            ws.cell(row=r, column=c, value=
